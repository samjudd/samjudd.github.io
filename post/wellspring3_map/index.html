<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Wellspring3: Hex Map Creation | Sam Judd</title><meta name=keywords content><meta name=description content="This is my first blog post for work I&rsquo;m doing actually right now as opposed to catchup. Very exciting! I started out this week working on making a hex map for Wellspring3 in Godot. The great part about using Godot was that they already have a TileMap class ready-to-go for creating tilemaps. It enables you to create and save sets of tiles to use for the map as well as place, rotate, and access tiles via code."><meta name=author content="Sam Judd"><link rel=canonical href=https://samjudd.github.io/post/wellspring3_map/><link href=/assets/css/stylesheet.min.3839cf02b87f30309470412461116907caabd1b3ec3f5d015df618da2d034992.css integrity="sha256-ODnPArh/MDCUcEEkYRFpB8qr0bPsP10BXfYY2i0DSZI=" rel="preload stylesheet" as=style><link rel=icon href=https://samjudd.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://samjudd.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://samjudd.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://samjudd.github.io/apple-touch-icon.png><link rel=mask-icon href=https://samjudd.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><meta property="og:title" content="Wellspring3: Hex Map Creation"><meta property="og:description" content="This is my first blog post for work I&rsquo;m doing actually right now as opposed to catchup. Very exciting! I started out this week working on making a hex map for Wellspring3 in Godot. The great part about using Godot was that they already have a TileMap class ready-to-go for creating tilemaps. It enables you to create and save sets of tiles to use for the map as well as place, rotate, and access tiles via code."><meta property="og:type" content="article"><meta property="og:url" content="https://samjudd.github.io/post/wellspring3_map/"><meta property="article:published_time" content="2021-03-29T12:12:21-07:00"><meta property="article:modified_time" content="2021-03-29T12:12:21-07:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Wellspring3: Hex Map Creation"><meta name=twitter:description content="This is my first blog post for work I&rsquo;m doing actually right now as opposed to catchup. Very exciting! I started out this week working on making a hex map for Wellspring3 in Godot. The great part about using Godot was that they already have a TileMap class ready-to-go for creating tilemaps. It enables you to create and save sets of tiles to use for the map as well as place, rotate, and access tiles via code."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://samjudd.github.io/post/"},{"@type":"ListItem","position":2,"name":"Wellspring3: Hex Map Creation","item":"https://samjudd.github.io/post/wellspring3_map/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Wellspring3: Hex Map Creation","name":"Wellspring3: Hex Map Creation","description":"This is my first blog post for work I\u0026amp;rsquo;m doing actually right now as opposed to catchup. Very exciting! I started out this week working on making a hex map for Wellspring3 in …","keywords":[],"articleBody":"This is my first blog post for work I’m doing actually right now as opposed to catchup. Very exciting! I started out this week working on making a hex map for Wellspring3 in Godot. The great part about using Godot was that they already have a TileMap class ready-to-go for creating tilemaps. It enables you to create and save sets of tiles to use for the map as well as place, rotate, and access tiles via code. Unfortunately, it is missing a couple critical features for creating hex tilemaps. The main issue is that it doesn’t actually support a hex grid, only a square one. Secondly, Godot doesn’t support custom properties for tiles. This means that say some tiles cost twice as much to move across as others, there’s no way for Godot to store this natively. This just meant that I had to develop these features myself.\nSquare Grid - Hex Grid In order to create a useable hex map, I needed to create the features below.\n I need to be able to tile hexes in the editor (as opposed to squares) and have them line up properly. I need to be able to click on the screen and know which tile I’m clicking on so that it can be selected. If I have a given amount of movement points I need to know which hexes I can reach.  Tiling Hexes The Godot TileMap implementation has an option for a Half Offset that basically offsets every other row/colum by half a tile width. This is perfect for making hex maps. Setting this Half Offset property to Offset Y offsets every other square column which is what I used. The picture below shows both the underlying square grid (super faint orange lines) and the hex tiles. Note that because they are hexes the dimensions of the square tiles are actually smaller than the hex. I have 140 x 120 px tiles and the square dimensions are 104 x 120 px to tile the hexes properly. I just determined this by changing the 104 until it looked right.\nScreen-to-Hex Conversion Godot TileMap has a function to convert screen clicks into tile clicks, but this works on the square grid, which as can be seen does not line up with the actual hex tiles. Luckily, Red Blob Games had some instructions on an implementation for converting pixel coordinates to hex coordinates. I was just able to directly implement the pseudo-code on the site for pixel_to_hex and hex_round, since this application didn’t require any modifications.\nHex Map Pathfinding I needed an algorithm that could search the hex map I had for all reachable points given that tiles could have different costs. This was done through implementing Dijkstra’s algorithm. Once again, Red Blob Games had some great resources here and here that I used. A quick but important side note is that C# does not have a native priority queue implementation, so I used Nuget to download this one. I modified the pseudo-code shown in the first link slightly to use a different function to find neighbors since the hex map has different neighbors than a square grid. The neighbors function description can, unsurprisingly, also be found at Red Blob Games here.\nI needed to make one more change to the algorithm described on Red Blob because the goal of my search is to find all hexes within range rather than the shortest path to a specific hex. The algorithm as shown ends when the goal location is found. My implementation instead ends when all hexes that are reachable have been visited. This is done by giving a max range of hexes to search and then only adding new hexes to the frontier to explore if the cost to reach them doesn’t exceed the max range. The Dijkstra iteration then ends when the frontier is out of possible hexes to explore. The results of the pathfinding algorithm are shown below. Grass hexes have a movement cost of 2, forest hexes 4, and the total movement range is 8. The start hex is in the middle and highlighed with a tan border, and the blue lines show paths to all possible hexes.\nStoring Custom Hex Properties The other major task to finish my hex map implementation was a way to store custom properties for each hex. The main relevant property that Godot stores for each hex is an ID number that identifies which sprite is used as the hex model. I loop through each hex in the map and pull the ID and location for it. I then use a dictionary I create elsewhere to map each ID to the amount of (base) movement points that it should cost to traverse that hex. I then store these in a 2D array so that hex property lookup is as easy as indexing into the hex location in the array. This is implemented in C# as a List. Hex information is stored in the 2D array as a custom HexTile object so that the custom properties can be expanded as needed to accomodate whatever the game requires. Because the location of the hex is also the way to index into the array, I use [0,0] as the top left of the map so there are no negative locations that would make negative indices.\nWorking with C# lists for the first times, I learned that allocating capacity to the list does not make you able to index into a spot in that list, you actually need to put an object there first. So List[x] = T won’t work but List.Insert(T, x) will if there is not something there already. Hopefully this might be useful for someone else.\nI also had to write a custom function for detecting if a tile exists in the map, since I can’t use the existing List.Contains() function with a list of lists. My custom contains function basically checks that the x and y location that was clicked is non-negative and within the bounds of the map. Having confirmed that the location in the array has been populated, I can then index into that location and check if the tile ID is not -1 since that is the “no tile” ID.\nNext Work Now that I have what I’d consider a minimum viable product for a functional map, the next to-do is to create the basic framework for a character. My initial thoughts on what the character needs to be able to do is shown below.\n Able to move from hex center to hex center along the paths determined by Dijkstra’s algorithm. Show its attack range. Store custom properties for the particular character. Be able to be selected and deselected. Reset its movement/action points upon a new turn.  The full source code for this project can be found in my github in the wellspring3 repo. As always, thanks for reading.\n","wordCount":"1146","inLanguage":"en","datePublished":"2021-03-29T12:12:21-07:00","dateModified":"2021-03-29T12:12:21-07:00","author":{"@type":"Person","name":"Sam Judd"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://samjudd.github.io/post/wellspring3_map/"},"publisher":{"@type":"Organization","name":"Sam Judd","logo":{"@type":"ImageObject","url":"https://samjudd.github.io/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://samjudd.github.io/ accesskey=h title="Sam Judd (Alt + H)">Sam Judd</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Wellspring3: Hex Map Creation</h1><div class=post-meta>March 29, 2021&nbsp;·&nbsp;Sam Judd</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#square-grid---hex-grid aria-label="Square Grid -&amp;gt; Hex Grid">Square Grid -> Hex Grid</a><ul><li><a href=#tiling-hexes aria-label="Tiling Hexes">Tiling Hexes</a></li><li><a href=#screen-to-hex-conversion aria-label="Screen-to-Hex Conversion">Screen-to-Hex Conversion</a></li><li><a href=#hex-map-pathfinding aria-label="Hex Map Pathfinding">Hex Map Pathfinding</a></li></ul></li><li><a href=#storing-custom-hex-properties aria-label="Storing Custom Hex Properties">Storing Custom Hex Properties</a></li><li><a href=#next-work aria-label="Next Work">Next Work</a></li></ul></div></details></div><div class=post-content><p>This is my first blog post for work I&rsquo;m doing actually right now as opposed to catchup.
Very exciting!
I started out this week working on making a hex map for Wellspring3 in <a href=https://godotengine.org>Godot</a>.
The great part about using Godot was that they already have a <a href=https://docs.godotengine.org/en/stable/tutorials/2d/using_tilemaps.html>TileMap</a> class ready-to-go for creating tilemaps.
It enables you to create and save sets of tiles to use for the map as well as place, rotate, and access tiles via code.
Unfortunately, it is missing a couple critical features for creating hex tilemaps.
The main issue is that it doesn&rsquo;t actually support a hex grid, only a square one.
Secondly, Godot doesn&rsquo;t support custom properties for tiles.
This means that say some tiles cost twice as much to move across as others, there&rsquo;s no way for Godot to store this natively.
This just meant that I had to develop these features myself.</p><h2 id=square-grid---hex-grid>Square Grid -> Hex Grid<a hidden class=anchor aria-hidden=true href=#square-grid---hex-grid>#</a></h2><p>In order to create a useable hex map, I needed to create the features below.</p><ol><li>I need to be able to tile hexes in the editor (as opposed to squares) and have them line up properly.</li><li>I need to be able to click on the screen and know which tile I&rsquo;m clicking on so that it can be selected.</li><li>If I have a given amount of movement points I need to know which hexes I can reach.</li></ol><h3 id=tiling-hexes>Tiling Hexes<a hidden class=anchor aria-hidden=true href=#tiling-hexes>#</a></h3><p>The Godot TileMap implementation has an option for a <code>Half Offset</code> that basically offsets every other row/colum by half a tile width.
This is perfect for making hex maps.
Setting this <code>Half Offset</code> property to <code>Offset Y</code> offsets every other square column which is what I used.
The picture below shows both the underlying square grid (super faint orange lines) and the hex tiles.
Note that because they are hexes the dimensions of the square tiles are actually smaller than the hex.
I have <code>140 x 120 px</code> tiles and the square dimensions are <code>104 x 120 px</code> to tile the hexes properly.
I just determined this by changing the <code>104</code> until it looked right.</p><p><img src=/wellspring3_map/half_offset_example.png#center alt="Half Offset Example"></p><h3 id=screen-to-hex-conversion>Screen-to-Hex Conversion<a hidden class=anchor aria-hidden=true href=#screen-to-hex-conversion>#</a></h3><p>Godot TileMap has a function to convert screen clicks into tile clicks, but this works on the square grid, which as can be seen does not line up with the actual hex tiles.
Luckily, <a href=https://www.redblobgames.com/grids/hexagons/#pixel-to-hex>Red Blob Games</a> had some instructions on an implementation for converting pixel coordinates to hex coordinates.
I was just able to directly implement the pseudo-code on the site for <code>pixel_to_hex</code> and <code>hex_round</code>, since this application didn&rsquo;t require any modifications.</p><h3 id=hex-map-pathfinding>Hex Map Pathfinding<a hidden class=anchor aria-hidden=true href=#hex-map-pathfinding>#</a></h3><p>I needed an algorithm that could search the hex map I had for all reachable points given that tiles could have different costs.
This was done through implementing Dijkstra&rsquo;s algorithm.
Once again, Red Blob Games had some great resources <a href=https://www.redblobgames.com/pathfinding/a-star/introduction.html#dijkstra>here</a> and <a href=https://www.redblobgames.com/grids/hexagons/#pathfinding>here</a> that I used.
A quick but important side note is that C# does not have a native priority queue implementation, so I used Nuget to download <a href=https://www.nuget.org/packages/OptimizedPriorityQueue/>this</a> one.
I modified the pseudo-code shown in the first link slightly to use a different function to find neighbors since the hex map has different neighbors than a square grid.
The neighbors function description can, unsurprisingly, also be found at Red Blob Games <a href=https://www.redblobgames.com/grids/hexagons/#neighbors>here</a>.</p><p>I needed to make one more change to the algorithm described on Red Blob because the goal of my search is to find all hexes within range rather than the shortest path to a specific hex.
The algorithm as shown ends when the goal location is found.
My implementation instead ends when all hexes that are reachable have been visited.
This is done by giving a max range of hexes to search and then only adding new hexes to the frontier to explore if the cost to reach them doesn&rsquo;t exceed the max range.
The Dijkstra iteration then ends when the frontier is out of possible hexes to explore.
The results of the pathfinding algorithm are shown below.
Grass hexes have a movement cost of 2, forest hexes 4, and the total movement range is 8.
The start hex is in the middle and highlighed with a tan border, and the blue lines show paths to all possible hexes.</p><p><img src=/wellspring3_map/pathfinding_example.png#center alt="Pathfinding Example"></p><h2 id=storing-custom-hex-properties>Storing Custom Hex Properties<a hidden class=anchor aria-hidden=true href=#storing-custom-hex-properties>#</a></h2><p>The other major task to finish my hex map implementation was a way to store custom properties for each hex.
The main relevant property that Godot stores for each hex is an ID number that identifies which sprite is used as the hex model.
I loop through each hex in the map and pull the ID and location for it.
I then use a dictionary I create elsewhere to map each ID to the amount of (base) movement points that it should cost to traverse that hex.
I then store these in a 2D array so that hex property lookup is as easy as indexing into the hex location in the array.
This is implemented in C# as a <code>List&lt;List&lt;HexTile>></code>.
Hex information is stored in the 2D array as a custom <code>HexTile</code> object so that the custom properties can be expanded as needed to accomodate whatever the game requires.
Because the location of the hex is also the way to index into the array, I use <code>[0,0]</code> as the top left of the map so there are no negative locations that would make negative indices.</p><p>Working with C# lists for the first times, I learned that allocating capacity to the list does not make you able to index into a spot in that list, you actually need to put an object there first.
So <code>List&lt;T>[x] = T</code> won&rsquo;t work but <code>List&lt;T>.Insert(T, x)</code> will if there is not something there already.
Hopefully this might be useful for someone else.</p><p>I also had to write a custom function for detecting if a tile exists in the map, since I can&rsquo;t use the existing <code>List&lt;T>.Contains()</code> function with a list of lists.
My custom contains function basically checks that the x and y location that was clicked is non-negative and within the bounds of the map.
Having confirmed that the location in the array has been populated, I can then index into that location and check if the tile ID is not <code>-1</code> since that is the &ldquo;no tile&rdquo; ID.</p><h2 id=next-work>Next Work<a hidden class=anchor aria-hidden=true href=#next-work>#</a></h2><p>Now that I have what I&rsquo;d consider a minimum viable product for a functional map, the next to-do is to create the basic framework for a character.
My initial thoughts on what the character needs to be able to do is shown below.</p><ol><li>Able to move from hex center to hex center along the paths determined by Dijkstra&rsquo;s algorithm.</li><li>Show its attack range.</li><li>Store custom properties for the particular character.</li><li>Be able to be selected and deselected.</li><li>Reset its movement/action points upon a new turn.</li></ol><p>The full source code for this project can be found in my github in the <a href=https://github.com/samjudd/wellspring3>wellspring3</a> repo.
As always, thanks for reading.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://samjudd.github.io/>Sam Judd</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>